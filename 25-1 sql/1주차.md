# Week0_TIL

## Subqueries


```sql
SELECT *
FROM t1
WHERE column1  -- outer query
    = (SELECT column1 FROM t2); -- subquery
```

- more readable than complex joins or unions

- can return a scalar, a single row, a single column, or a table

- A subquery's outer statement: `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `SET`, or `DO`.

### 15.2.15.1. The Subquery as Scalar Operand

Ex1) `LIMIT`   : simplest

```sql
SELECT *
FROM employees
ORDER BY salary DESC
LIMIT 5;
```
Ex2) `DEFAULT`   : not a subquery
```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  created_at TIMESTAMP DEFAULT NOW()
  );
```

### 15.2.15.2. Comparisons Using Subqueries

comparison_operator:
```
=  >  <  >=  <=  <>  !=  <=>
```

```sql
SELECT *
FROM t1 AS t
WHERE 2 = (SELECT COUNT(*)
           FROM t1
           WHERE t1.id = t.id);
-- It finds all rows in table t1 containing a value that occurs twice in a given column
```

### 15.2.15.3. `ANY`, `IN`, `SOME`을 활용한 서브쿼리  

#### `ANY` 키워드  
- `ANY`는 서브쿼리가 반환하는 값 중 **하나라도 조건을 만족하면** `TRUE`를 반환한다.  
- 예제:  
  ```sql
  SELECT s1
  FROM t1
  WHERE s1 > ANY (SELECT s1 FROM t2);
  ```
  - `t1`에 `(10)`이 존재할 때  
    - `t2`에 `(21, 14, 7)`이 있으면 `TRUE`  
    - `t2`에 `(20, 10)`이 있으면 `FALSE`  
    - `t2`에 `(NULL, NULL, NULL)`만 있으면 `UNKNOWN`

#### `IN`과 `ANY`의 관계  
- `IN`은 `= ANY`의 **별칭(alias)** 이다. 즉, 다음 두 문장은 동일하다.  
  ```sql
  SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);
  SELECT s1 FROM t1 WHERE s1 IN (SELECT s1 FROM t2);
  ```
  
#### `IN`과 `ANY`의 차이점  
- **`IN`은 여러 개의 컬럼(튜플) 비교 가능하지만, `ANY`는 지원하지 않는다.**  
  ```sql
  -- ✅ IN 사용 (튜플 비교 가능)
  SELECT *
  FROM products
  WHERE (category, price) IN (('Electronics', 1000), ('Books', 20));
  ```
  ```sql
  -- ❌ ANY는 튜플 비교 불가능 (오류 발생)
  WHERE (category, price) = ANY (SELECT category, price FROM discount_products);
  ```
  ```sql
  -- ✅ ANY는 단일 컬럼 비교 가능
  SELECT *
  FROM products
  WHERE price = ANY (SELECT discount_price FROM discount_products);
  ```

#### `NOT IN`과 `<> ANY`의 차이  
- `NOT IN`은 `<> ANY`와 같지 않다.  
  - `NOT IN`은 `<> ALL`과 같음 → 즉, 모든 값과 다를 때 `TRUE`  
  - 이에 대한 내용은 **15.2.15.4. Subqueries with ALL**에서 다룸  

#### `SOME` 키워드  
- `SOME`은 `ANY`의 **별칭(alias)** 이므로 완전히 동일한 기능을 수행한다.  
  ```sql
  SELECT s1 FROM t1 WHERE s1 <> ANY (SELECT s1 FROM t2);
  SELECT s1 FROM t1 WHERE s1 <> SOME (SELECT s1 FROM t2);
  ```
  - `SOME`은 거의 사용되지 않지만, 의미를 명확히 전달하는 데 유용할 수 있음  
  - 예를 들어, `"어떤 b와도 다르다"`보다는 **"어떤 b가 있고, 그 b와 다르다"**라는 의미를 강조할 수 있음  

---

### 📌 요약 (중요 개념 정리)  
1. **`ANY`는 서브쿼리 결과 중 하나라도 조건을 만족하면 `TRUE` 반환**  
2. **`IN`은 `= ANY`의 별칭**  
3. **`IN`은 여러 컬럼(튜플) 비교 가능하지만, `ANY`는 단일 컬럼만 비교 가능**  
4. **`NOT IN`은 `<> ALL`과 동일하며, `<> ANY`와 다름**  
5. **`SOME`은 `ANY`의 별칭이지만 잘 사용되지 않음**
### 15.2.15.4. `ALL`을 활용한 서브쿼리  

#### `ALL` 키워드  
- `ALL`은 비교 연산자와 함께 사용되며, **서브쿼리가 반환하는 모든 값에 대해 조건을 만족하면 `TRUE`를 반환**한다.  
- 예제:  
  ```sql
  SELECT s1
  FROM t1
  WHERE s1 > ALL (SELECT s1 FROM t2);
  ```
  - `t1`에 `(10)`이 존재할 때  
    - `t2`가 `(-5, -3, 5)`이면 `TRUE`  
    - `t2`가 비어있으면 `TRUE`  
    - `t2`가 `(12, 6, NULL, -100)`이면 `FALSE`  
    - `t2`가 `(0, NULL, 1)`이면 `UNKNOWN`

#### `t2`가 비어있을 때의 동작  
```sql
SELECT * FROM t1 WHERE 1 > ALL (SELECT s1 FROM t2);
-- ✅ TRUE
```
```sql
SELECT * FROM t1 WHERE 1 > (SELECT s1 FROM t2);
-- ❌ NULL (오류 발생 가능)
```
```sql
SELECT * FROM t1 WHERE 1 > ALL (SELECT MAX(s1) FROM t2);
-- ❌ NULL
```
- `ALL`을 사용하면 `t2`가 비어있을 경우에도 `TRUE`를 반환할 수 있음  
- 하지만 `SELECT MAX(s1) FROM t2`처럼 `NULL`이 반환될 가능성이 있으면 주의해야 함  

---

### `NOT IN`은 `<> ALL`의 별칭  
- `NOT IN`과 `<> ALL`은 동일한 의미를 갖는다.  
  ```sql
  -- <> ALL
  SELECT s1
  FROM t1
  WHERE s1 <> ALL (SELECT s1 FROM t2);

  -- NOT IN
  SELECT s1
  FROM t1
  WHERE s1 NOT IN (SELECT s1 FROM t2);
  ```
  - 즉, `NOT IN`은 서브쿼리의 모든 값과 다를 때 `TRUE`를 반환  

---

### `ALL`과 `NOT IN`을 사용할 수 있는 경우  
- 다음 두 조건을 만족해야 함  
  1. **서브쿼리가 단일 컬럼만 반환해야 함**  
  2. **서브쿼리가 특정 컬럼 표현식에 의존하지 않아야 함**  

---

### 📌 요약 (중요 개념 정리)  
1. **`ALL`은 서브쿼리 결과의 모든 값에 대해 조건이 `TRUE`일 때만 `TRUE` 반환**  
2. **서브쿼리 결과가 비어 있으면 `ALL`은 `TRUE`, `IN`은 `FALSE` 또는 `NULL`을 반환할 수 있음**  
3. **`NOT IN`은 `<> ALL`의 별칭**  
4. **`ALL`과 `NOT IN`을 사용하려면 서브쿼리는 반드시 단일 컬럼을 반환해야 함**

### 15.2.15.6. `EXISTS` 및 `NOT EXISTS`를 활용한 서브쿼리  

#### `EXISTS` 키워드  
- 서브쿼리가 **한 개 이상의 행을 반환하면** `EXISTS`는 `TRUE`를 반환  
- **행이 하나도 없으면 `FALSE`**  
- 주로 특정 조건을 만족하는 데이터가 존재하는지 확인하는 데 사용됨  

##### ✅ 하나 이상의 도시에 존재하는 매장 유형 찾기  
```sql
SELECT DISTINCT store_type
FROM stores s
WHERE EXISTS
    (SELECT *
    FROM cities_stores cs
    WHERE cs.store_type = s.store_type);
```
- `cities_stores` 테이블에 존재하는 `store_type`이 `stores` 테이블에도 있다면 `TRUE`  
- 즉, **적어도 하나의 도시에 있는 매장 유형을 반환**  

---

#### `NOT EXISTS` 키워드  
- 서브쿼리가 **행을 반환하지 않으면** `TRUE`,  
- **행이 하나라도 있으면 `FALSE`**  
- 특정 조건을 **만족하지 않는 데이터**를 찾는 데 유용  

##### ✅ 어느 도시에도 없는 매장 유형 찾기  
```sql
SELECT DISTINCT store_type
FROM stores s
WHERE NOT EXISTS
    (SELECT *
    FROM cities_stores cs
    WHERE cs.store_type = s.store_type);
```
- `cities_stores` 테이블에 존재하지 않는 `store_type`만 조회  
- 즉, **어느 도시에서도 운영되지 않는 매장 유형 반환**  

---

#### `EXISTS`를 중첩하여 모든 도시에 있는 매장 유형 찾기  
```sql
SELECT DISTINCT store_type
FROM stores s
WHERE NOT EXISTS (
    SELECT *  
    FROM cities c  
    WHERE NOT EXISTS (
        SELECT *  
        FROM cities_stores cs  
        WHERE cs.city = c.city  
        AND cs.store_type = s.store_type));
```
- 내부 `NOT EXISTS`: 특정 `store_type`이 **해당 `city`에 존재하지 않으면 `TRUE` 반환**  
- 외부 `NOT EXISTS`: **하나라도 `TRUE`가 있으면 해당 `store_type`을 제외**  
- 최종적으로 **모든 도시에 존재하는 `store_type`만 반환**  

---

### 📌 요약 (중요 개념 정리)  
1. **`EXISTS`는 서브쿼리가 하나 이상의 행을 반환하면 `TRUE`**  
2. **`NOT EXISTS`는 서브쿼리가 행을 반환하지 않으면 `TRUE`**  
3. **`EXISTS`는 특정 조건을 만족하는 데이터가 존재하는지 확인할 때 유용**  
4. **`NOT EXISTS`는 특정 조건을 만족하지 않는 데이터를 찾을 때 유용**  
5. **중첩된 `EXISTS`를 활용하면 "모든 데이터에 해당하는 값"을 찾을 수 있음**


### 15.2.15.10. Subquery Errors

⚠️Unsupported subquery syntax:
```sql
SELECT * 
FROM t1 
WHERE s1 IN (
    SELECT s2 
    FROM t2 
    ORDER BY s1 
    LIMIT 1
);
-- IN 서브쿼리 안에서 ORDER BY 절을 직접 사용할 수 없음.
```

⚠️Incorrect number of columns from subquery:
```sql
SELECT
    (SELECT column1, column2
    FROM t2)
FROM t1;
-- SELECT 절 안에서 서브쿼리를 값으로 사용할 경우, 서브쿼리는 반드시 단일 값을 반환해야 함.
```

⚠️Incorrect number of rows from subquery:
```SQL
SELECT *
FROM t1
WHERE column1
    = (SELECT column1 FROM t2);
-- t2에서 column1이 여러 개의 값을 반환할 경우 이러한 오류 발생
-- 여러 행을 `=`로 비교할 수 없음
```
```sql
[correct query]
SELECT *
FROM t1
WHERE column1
    = ANY (SELECT column1 FROM t2);
-- ANY를 사용할 경우, t2에서 column1이 여러 개의 값을 반환하더라도 사용 가능
```

### 15.2.15.11. Optimizing Subqueries

Move clauses from outside to inside the subquery.

Example1:
```sql
SELECT *
FROM t1
WHERE s1 IN (
    SELECT s1 FROM t1
    UNION ALL
    SELECT s1 FROM t2);
-- UNION ALL로 합친 결과에 대해 단일 검사
-- 데이터량이 많을수록 더 효율적
```
```sql
SELECT *
FROM t1
WHERE s1 IN (SELECT s1 FROM t1)
    OR s1 IN (SELECT s1 FROM t2);
-- 각각 IN을 별도 조건으로 검사
-- 데이터량이 많으면 성능 저하 가능성 있음
```

Example2:
```sql
SELECT
    (SELECT column1 + 5 FROM t1)
FROM t2;
-- 서브쿼리 내에서 +5
-- 서브쿼리 내에서 미리 계산
```
```sql
SELECT
    (SELECT column1 FROM t1) + 5
FROM t2;
-- 서브쿼리 결과에 +5
-- 메인쿼리에서 추가 연산 수행
-- 서브쿼리를 반복적으로 실행해야 할 수 있음
```

## CTE: `WITH`

A common table expression (CTE) is a named temporary result set that exists within the scope of a single statement and that can be referred to later within that statement, possibly multiple times.

To specify CTEs, use a `WITH` clause that has one or more comma-separated subclauses. Each subclause provides a subquery that produces a result set, and associates a name with the subquery.

Example:
```sql
WITH
  cte1 AS (SELECT a, b FROM table1),
  cte2 AS (SELECT c, d FROM table2)

SELECT b, d
FROM cte1
JOIN cte2
WHERE cte1.a = cte2.c;
```

Determination of column names for a given CTE occurs as follows: These two queries are the same.

```sql
WITH cte (col1, col2) AS
(
  SELECT 1, 2
  UNION ALL
  SELECT 3, 4
)
SELECT col1, col2 FROM cte;
```
```sql
WITH cte AS
(
  SELECT 1 AS col1, 2 AS col2
  UNION ALL
  SELECT 3, 4
)
SELECT col1, col2 FROM cte;
```

A `WITH` clause is permitted in these contexts:
1. At the beginning of *SELECT, UPDATE*, and *DELETE* statements.
2. At the beginning of *subqueries*.

Only one `WITH` clause is permitted at the same level.
```sql
[⚠️illegal clause]
WITH cte1 AS (...)
WITH cte2 AS (...)
SELECT ...
```
```sql
[⚠️illegal clause]
WITH cte1 AS (...),
     cte1 AS (...)
SELECT ...
-- each CTE name must be unique to the clause
```
```sql
[legal clause]
WITH cte1 AS (...),
     cte2 AS (...)
SELECT ...
```

# 문제 풀이하기

## 문제1: 많이 주문한 테이블 찾기
> subquery

### 요구사항
식사 금액이 테이블 당 평균 식사 금액보다 더 많은 경우를 모두 출력하는 쿼리를 작성해주세요. 결과에는 tips 테이블에 있는 모든 컬럼이 포함되어야 합니다.

### 작성한 쿼리
```sql
SELECT *
FROM tips
WHERE total_bill >
  (SELECT AVG(total_bill) FROM tips)
```
![문제1](/image/image.png)

## 문제2: 레스토랑의 대목
> subquery

### 요구사항
요일별 매출액 합계를 구하고, 매출이 1500 달러 이상인 요일의 결제 내역을 모두 출력하는 쿼리를 작성해주세요. 쿼리 결과에는 tips 테이블에 있는 모든 컬럼이 포함되어야 합니다.

### 작성한 쿼리
조건에 해당하는 결제 내역을 **모두 출력**하기 위해서는 서브쿼리를 사용해야 한다.
```sql
SELECT *
FROM tips
WHERE day IN (
  SELECT day
  FROM tips
  GROUP BY day
  HAVING SUM(total_bill) > 1500
)
```
![문제2](/image/image2.png)


## 문제3: 식품분류별 가장 비싼 식품의 정보 조회하기
> subquery or WITH

### 요구사항
FOOD_PRODUCT 테이블에서 식품분류별로 가격이 제일 비싼 식품의 분류, 가격, 이름을 조회하는 SQL문을 작성해주세요. 이때 식품분류가 '과자', '국', '김치', '식용유'인 경우만 출력시켜 주시고 결과는 식품 가격을 기준으로 내림차순 정렬해주세요.

### 작성한 쿼리(subquery)
IN 절 안에 서브쿼리 사용

```sql
SELECT
    CATEGORY,
    PRICE AS MAX_PRICE,
    PRODUCT_NAME
FROM FOOD_PRODUCT
WHERE (CATEGORY, PRICE)
    IN (
        SELECT
            CATEGORY,
            MAX(PRICE)
        FROM FOOD_PRODUCT
        GROUP BY CATEGORY
    )
    AND CATEGORY IN ('과자', '국', '김치', '식용유')
GROUP BY CATEGORY
ORDER BY PRICE DESC;
```

### 작성한 쿼리(WITH)
가독성 향상

```sql
WITH CTE AS (
    SELECT
        CATEGORY,
        MAX(PRICE) AS MAX_PRICE
    FROM FOOD_PRODUCT
    GROUP BY CATEGORY
)
SELECT
    F.CATEGORY,
    F.PRICE AS MAX_PRICE,
    F.PRODUCT_NAME
FROM FOOD_PRODUCT F
JOIN CTE
    ON F.CATEGORY = CTE.CATEGORY
    AND F.PRICE = CTE.MAX_PRICE
WHERE F.CATEGORY IN ('과자', '국', '김치', '식용유')
ORDER BY F.PRICE DESC;
```

![문제3](/image/image3.png)